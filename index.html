<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Telegram → RSS feeds</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <h1>Telegram → RSS</h1>
  <div class="meta" id="meta">Loading…</div>

  <div class="feeds" id="feeds"></div>
  <div id="errors"></div>

  <script>
    // ---- Relative time formatting ----
    function formatRelativeTime(date) {
      const now = new Date();
      const diffMs = now - date;
      const diffSec = Math.floor(diffMs / 1000);
      const diffMin = Math.floor(diffSec / 60);
      const diffHours = Math.floor(diffMin / 60);
      const diffDays = Math.floor(diffHours / 24);

      if (diffMin < 1) return 'just now';
      if (diffMin < 60) return `${diffMin} minute${diffMin === 1 ? '' : 's'} ago`;
      if (diffHours < 24) return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
      if (diffDays < 30) return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
      return 'more than 30 days ago';
    }

    // ---- Main loader ----
    async function loadFeeds() {
      const metaEl = document.getElementById('meta');
      const feedsEl = document.getElementById('feeds');
      const errorsEl = document.getElementById('errors');

      const buildId = document.lastModified;

      // load localStorage state
      let saved = null;
      try {
        saved = JSON.parse(localStorage.getItem('telegramRssState') || 'null');
      } catch {
        saved = null;
      }

      const prevBuildId = saved?.buildId || null;
      const prevChannels = Array.isArray(saved?.channels) ? saved.channels : [];
      const isNewBuild = prevBuildId && prevBuildId !== buildId;
      const prevSet = new Set(prevChannels);

      try {
        const resp = await fetch('channels.txt');
        if (!resp.ok) throw new Error('Failed to load channels.txt');

        const text = await resp.text();
        const lines = text
          .split('\n')
          .map(l => l.trim())
          .filter(l => l.length > 0 && !l.startsWith('#'));

        const lastModifiedDate = new Date(buildId);
        const relative = formatRelativeTime(lastModifiedDate);
        const absolute = lastModifiedDate.toLocaleString();

        metaEl.textContent = `Channels: ${lines.length} · Updated ${relative} (${absolute})`;

        // Build items with new-channel detection
        const items = lines.map(channel => {
          const isNewChannel = isNewBuild && !prevSet.has(channel);
          const safe = channel.replace('@', '');
          const basePath =
            window.location.origin +
            window.location.pathname.replace(/\/[^\/]*$/, '');
          const feedUrl = `${basePath}/${safe}.xml`;

          return { channel, safe, feedUrl, isNew: isNewChannel };
        });

        // Sort: new channels first, then alphabetical
        items.sort((a, b) => {
          if (a.isNew && !b.isNew) return -1;
          if (!a.isNew && b.isNew) return 1;
          return a.channel.localeCompare(b.channel);
        });

        // Render feed list
        for (const item of items) {
          const feedDiv = document.createElement('div');
          feedDiv.className = 'feed';

          const mainDiv = document.createElement('div');
          mainDiv.className = 'feed-main';

          const nameDiv = document.createElement('div');
          nameDiv.className = 'feed-name';
          nameDiv.textContent = item.channel + (item.isNew ? '  (new)' : '');

          const urlDiv = document.createElement('div');
          urlDiv.className = 'feed-url';
          urlDiv.textContent = item.feedUrl;

          mainDiv.appendChild(nameDiv);
          mainDiv.appendChild(urlDiv);

          const buttonsDiv = document.createElement('div');
          buttonsDiv.className = 'buttons';

          const copyBtn = document.createElement('button');
          copyBtn.className = 'copy-btn';
          copyBtn.textContent = 'Copy URL';
          copyBtn.dataset.url = item.feedUrl;

          buttonsDiv.appendChild(copyBtn);

          feedDiv.appendChild(mainDiv);
          feedDiv.appendChild(buttonsDiv);

          feedsEl.appendChild(feedDiv);
        }

        // Save state (for next build comparison)
        try {
          localStorage.setItem(
            'telegramRssState',
            JSON.stringify({
              buildId,
              channels: lines,
            })
          );
        } catch (e) {
          console.warn('Failed to save state to localStorage', e);
        }

        // ---- Errors block ----
        try {
          const errResp = await fetch('_errors.log');
          if (errResp.ok) {
            const errText = await errResp.text();
            if (errText.trim().length > 0) {
              const box = document.createElement('div');
              box.className = 'error-box';
              box.innerHTML = `
                <div><strong>Some channels failed to update in the last run.</strong></div>
                <pre>${errText.replace(/[&<>]/g, c => (
                  {'&':'&amp;','<':'&lt;','>':'&gt;'}[c]
                ))}</pre>
              `;
              errorsEl.appendChild(box);
            }
          }
        } catch (e) {
          console.warn('Failed to load _errors.log', e);
        }

      } catch (e) {
        console.error(e);
        metaEl.textContent = 'Failed to load channels.';
      }
    }

    // ---- Copy button handler ----
    document.addEventListener('click', async (event) => {
      const btn = event.target.closest('.copy-btn');
      if (!btn) return;

      const url = btn.dataset.url;
      if (!url) return;

      try {
        await navigator.clipboard.writeText(url);
        const original = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = original; }, 1200);
      } catch (e) {
        console.error(e);
        alert('Failed to copy. You can copy the URL manually.');
      }
    });

    loadFeeds();
  </script>
</body>
</html>
